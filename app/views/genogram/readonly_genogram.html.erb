       <% flash.each do |type, msg| %>
      <div class="alert alert-info">
        <%= msg %>
      </div>
    <% end %>
    <script type="text/javascript">
      $(".alert" ).fadeOut(6000);
    </script>
  <script src="https://use.fontawesome.com/ae8d15b2f5.js"></script>
  <script type="javascript" src="/javascripts/ZoomSlider.js"></script>
  <style type="text/css">
    /* Left modal */
    .listing-tab{
    padding:0;    
}.related-artist .artist-next{padding-left:0;}
.related-artist .col-md-12{padding-right:0;}
.play-mix-btn span {
    color: #1775bc;
}
.related-artist img{width:100%;}
.related-artist h3 {
    font-size: 17px;
    margin-left: 15px;
    margin-top: 9px;
}.related-artist{overflow:hidden;padding-bottom:10px;}
.listing-tab .tab-content ul{padding:0;margin:0;}
.listing-tab .tab-content ul li {
    list-style-type: none;
    border-bottom: 1px solid #eee;
    padding: 8px;
}.listing-tab .tab-content ul li {
    list-style-type: none;
    border-bottom: 1px solid #eee;
    padding: 8px;
    padding-left: 20px;
    font-size: 13px;
    color: #666;
}.listing-tab .tab-content ul li a{text-decoration:none; color:#666;}
.listing-tab .tab-content ul li span{display:inline-block;float:right;padding-right:10px;}
.listing-tab .nav-tabs>li,.nav-tabs>li a:hover{margin-bottom:0;background:none;}
.listing-tab .nav-tabs>li.active>a, .nav-tabs>li.active>a:hover, .nav-tabs>li.active>a:focus{border:none;background:none;}
.listing-tab .nav-tabs>li>a:hover{border-color:none;color:red;}
.listing-tab .nav-tabs>li>a{border:0;padding:17px 0 7px;color:#333;margin-left:15px;}
.listing-tab .nav-tabs>li.active>a{border-bottom:2px solid #bb0000;color:#000;}
.listing-tab{background-color:#fff;}

    /* CSS for the traditional context menu */
    .menu {
      display: none;
      position: absolute;
      opacity: 0;
      margin: 0;
      padding: 8px 0;
      z-index: 999;
      box-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12);
      list-style: none;
      background-color: #ffffff;
      border-radius: 4px;
    }

    .menu-item {
      display: block;
      position: relative;
      min-width: 60px;
      margin: 0;
      padding: 6px 16px;
      font: bold 12px sans-serif;
      color: rgba(0, 0, 0, .87);
      cursor: pointer;
    }

    .menu-item::before {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      pointer-events: none;
      content: "";
      width: 100%;
      height: 100%;
      background-color: #000000;
    }

    .menu-item:hover::before {
      opacity: .04;
    }

    .menu .menu {
      top: -8px;
      left: 100%;
    }

    .show-menu, .menu-item:hover > .menu {
      display: block;
      opacity: 1;
    }
    .displayNone{
      display: none;
    }
    /* Left & Right Panel */
      .modal.left .modal-dialog,
  .modal.right .modal-dialog {
    position: fixed;
    margin: auto;
    width: 420px;
    height: 100%;
    -webkit-transform: translate3d(0%, 0, 0);
        -ms-transform: translate3d(0%, 0, 0);
         -o-transform: translate3d(0%, 0, 0);
            transform: translate3d(0%, 0, 0);
  }

  .modal.left .modal-content,
  .modal.right .modal-content {
    height: 100%;
    overflow-y: auto;
  }
  
  .modal.left .modal-body,
  .modal.right .modal-body {
    padding: 15px 15px 80px;
  }

/*Left*/
  .modal.left.fade .modal-dialog{
    left: -320px;
    -webkit-transition: opacity 0.3s linear, left 0.3s ease-out;
       -moz-transition: opacity 0.3s linear, left 0.3s ease-out;
         -o-transition: opacity 0.3s linear, left 0.3s ease-out;
            transition: opacity 0.3s linear, left 0.3s ease-out;
  }
  
  .modal.left.fade.in .modal-dialog{
    left: 0;
  }
        
/*Right*/
  .modal.right.fade .modal-dialog {
    right: -320px;
    -webkit-transition: opacity 0.3s linear, right 0.3s ease-out;
       -moz-transition: opacity 0.3s linear, right 0.3s ease-out;
         -o-transition: opacity 0.3s linear, right 0.3s ease-out;
            transition: opacity 0.3s linear, right 0.3s ease-out;
  }
  
  .modal.right.fade.in .modal-dialog {
    right: 0;
  }

/* ----- MODAL STYLE ----- */
  .modal-content {
    border-radius: 0;
    border: none;
  }

  .modal-header {
    border-bottom-color: #EEEEEE;
    background-color: #FAFAFA;
  }

/* ----- v CAN BE DELETED v ----- */


.demo {
  padding-top: 60px;
  padding-bottom: 110px;
}

.btn-demo {
  margin: 15px;
  padding: 10px 15px;
  border-radius: 0;
  font-size: 16px;
  background-color: #FFFFFF;
}

.btn-demo:focus {
  outline: 0;
}

.demo-footer {
  position: fixed;
  bottom: 0;
  width: 100%;
  padding: 15px;
  background-color: #212121;
  text-align: center;
}

.demo-footer > a {
  text-decoration: none;
  font-weight: bold;
  font-size: 16px;
  color: #fff;
}
.active a{
  background-color: #fff !important;
}
#loading-overlay {
    position: absolute;
    width: 100%;
    height:100%;
    left: 0;
    top: 0;
    display: none;
    align-items: center;
    background-color: #000;
    z-index: 999;
    opacity: 0.5;
}
.loading-icon{ position:absolute;border-top:2px solid #fff;border-right:2px solid #fff;border-bottom:2px solid #fff;border-left:2px solid #767676;border-radius:25px;width:25px;height:25px;margin:0 auto;position:absolute;left:50%;margin-left:-20px;top:50%;margin-top:-20px;z-index:4;-webkit-animation:spin 1s linear infinite;-moz-animation:spin 1s linear infinite;animation:spin 1s linear infinite;}
@-moz-keyframes spin { 100% { -moz-transform: rotate(360deg); } }
@-webkit-keyframes spin { 100% { -webkit-transform: rotate(360deg); } }
@keyframes spin { 100% { -webkit-transform: rotate(360deg); transform:rotate(360deg); } } 
  </style>
<div id="loading-overlay">
	<input type="text" name="familyid" id="familyid" value="<%= params[:familyid] %>">
    <div class="loading-icon"></div>
</div>  
  <script id="code">
                  var i;
                  var obj;
                  var jsonData = new Array();
           $(document).ready(function(){ 
           	var familyid = $("#familyid").val();
           $.ajax({
                  type: 'GET',
                  data: {familyid:familyid},
                  contentType: 'application/json; charset=utf-8',
                  url: '/readonlygenogramData',
                  dataType: 'json',
                  success: function(data){
                  jsonData = data.doc;
                init();
                 }

               })
    });
    function init() {
     // if (window.goSamples) goSamples();  // init for these samples -- you don't need to call this
      var $ = go.GraphObject.make;
       myDiagram =
        $(go.Diagram, "myDiagramDiv",
          {
            initialAutoScale: go.Diagram.UniformToFill,
            "undoManager.isEnabled": true,
            "allowDrop": true,
            "draggingTool.isEnabled": false,
            // when a node is selected, draw a big yellow circle behind it
            nodeSelectionAdornmentTemplate:
              $(go.Adornment, "Auto",
                { layerName: "Grid" },  // the predefined layer that is behind everything else
                $(go.Shape, "Rectangle", { fill: "green", stroke: null }),
                $(go.Placeholder, { margin: 4 })
              ),
            layout:  // use a custom layout, defined below
              $(GenogramLayout, { direction: 90, layerSpacing: 90, columnSpacing: 30}),

          });
        zoomSlider = new ZoomSlider(myDiagram,
          {
            alignment: go.Spot.TopRight, alignmentFocus: go.Spot.TopRight,
            size: 250, buttonSize: 50, orientation: 'horizontal', opacity: 1
          });
    //================HyperText Start
    go.GraphObject.defineBuilder("HyperlinkText", function(args) {
  // the URL is required as the first argument, either a string or a side-effect-free function returning a string
  var url = go.GraphObject.takeBuilderArgument(args, undefined, function(x) { return typeof x === "string" || typeof x === "function"; });
  // the text for the HyperlinkText is the optional second argument, either a string or a side-effect-free function returning a string
  var text = go.GraphObject.takeBuilderArgument(args, null, function(x) { return typeof x === "string" || typeof x === "function"; });

  // see if the visual tree is supplied in the arguments to the "HyperlinkText"
  var anyGraphObjects = false;
  for (var i = 0; i < args.length; i++) {
    var a = args[i];
    if (a && a instanceof go.GraphObject) anyGraphObjects = true;
  }

  // define the click behavior
  var click =
    function(e, obj) {
      var u = obj._url;
      if (typeof u === "function") u = u(obj.findTemplateBinder());
      if (u) Invite();
    };

  // define the tooltip

  // if the text is provided, use a new TextBlock; otherwise assume the TextBlock is provided
  if (typeof (text) === "string" || typeof (text) === "function" || !anyGraphObjects) {
    if (text === null && typeof (url) === "string") text = url;
    var tb = go.GraphObject.make(go.TextBlock,
                {
                  "_url": url,
                  cursor: "pointer",
                  mouseEnter: function(e, obj) {
                    var u = obj._url;
                    if (typeof u === "function") u = u(obj.findTemplateBinder());
                    if (u) obj.isUnderline = true;
                  },
                  mouseLeave: function(e, obj) { obj.isUnderline = false; },
                  click: click,  // defined above
                }
              );
    if (typeof(text) === "string") {
      tb.text = text;
    } else if (typeof(text) === "function") {
      tb.bind(new go.Binding("text", "", text).ofObject())
    } else if (typeof (url) === "function") {
      tb.bind(new go.Binding("text", "", url).ofObject())
    }
    return tb;
  } else {
    function findTextBlock(obj) {
      if (obj instanceof go.TextBlock) return obj;
      if (obj instanceof go.Panel) {
        var it = obj.elements;
        while (it.next()) {
          var result = findTextBlock(it.value);
          if (result !== null) return result;
        }
      }
      return null;
    }
    return go.GraphObject.make(go.Panel,
      {
        "_url": url,
        cursor: "pointer",
        mouseEnter: function(e, panel) {
          var tb = findTextBlock(panel);
          var u = panel._url;
          if (typeof u === "function") u = u(panel.findTemplateBinder());
          if (tb !== null && u) tb.isUnderline = true;
        },
        mouseLeave: function(e, panel) {
          var tb = findTextBlock(panel);
          if (tb !== null) tb.isUnderline = false;
        },
        click: click,  // defined above
        toolTip: tooltip  // shared by all HyperlinkText panels
      }
    );
  }
});

    //=======================================================HyperText end

      myDiagram.nodeTemplate =
        $(go.Node, "Auto",
          $(go.Shape, "Ellipse", { fill: "lightskyblue" }),

        );

      function textStyle() {
        return { font: "12pt  Segoe UI,sans-serif", stroke: "white" };
      }



      // two different node templates, one for each sex,
      // named by the category value in the node data object

      myDiagram.nodeTemplateMap.add("M",  // male
        $(go.Node, "Auto",
            $(go.Shape, "Rectangle",
            {

            mouseEnter: function(e, obj) {
              obj.part.diagram.clearHighlighteds();
              obj.part.linksConnected.each(function(l) { highlightLink(l, true); });
              obj.part.findLinksInto().each(function(l) { highlightLink(l, true); });
              obj.part.isHighlighted = true;
              var tb = obj.part.findObject("TEXTBLOCK");
              if (tb !== null) tb.stroke = highlightColor;
            },
            mouseLeave: function(e, obj) {
              obj.part.diagram.clearHighlighteds();
              var tb = obj.part.findObject("TEXTBLOCK");
              if (tb !== null) tb.stroke = "black";
            }},
              { name: "OBJSHAPE", stroke: 'white', strokeWidth: 3.5,
              // set the port properties:
              portId: "", fromLinkable: false, toLinkable: false, cursor: "pointer" },
               new go.Binding("fill", "fillcolor")),
               new go.Binding("visible"),
          $(go.Panel, "Horizontal",
            $(go.Picture,
              {
                name: "Picture",
                desiredSize: new go.Size(70, 70),
                margin: 1.5,
              },
              new go.Binding("source", "img")),
            { click: function(e, obj) { viewProfile();zoomSlider.remove(); } },
            // define the panel where the text will appear
            $(go.Panel, "Table",
              {
                minSize: new go.Size(130, NaN),
                maxSize: new go.Size(150, NaN),
                margin: new go.Margin(6, 10, 0, 6),
                defaultAlignment: go.Spot.Left
              },
              $(go.RowColumnDefinition, { column: 2, width: 4 }),
             /* $(go.TextBlock,"Invite to Pidhi" ,textStyle(),  // the name
                {
                  row: 0, column: 0, columnSpan: 5,
                  font: "12pt Segoe UI,sans-serif",
                  editable: true, isMultiline: false,
                  minSize: new go.Size(10, 16)
                },
                new go.Binding("text", 'Invite')),*/
              $("HyperlinkText",
              function(node) { return "#"; },
              function(node) { return "Invite To Pidhi"; },
              {row: 0, column: 0, columnSpan: 5,stroke: "white",font: "8pt sans-serif", margin:5, minSize: new go.Size(10, 16)}),
            { click: function(e, obj) { viewProfile();zoomSlider.remove(); } },
              $(go.TextBlock, "", textStyle(),
                { row: 1, column: 0 }),
              $(go.TextBlock, textStyle(),
                {
                  row: 1, column: 1, columnSpan: 4,
                  editable: true, isMultiline: false,
                  minSize: new go.Size(10, 14),
                  margin: new go.Margin(0, 0, 0, 3)
                },
                new go.Binding("text", "fname").makeTwoWay()),
                //new go.Binding("text", "lname").makeTwoWay()),
            )  // end Table Panel
          ), // end Horizontal Panel

          $(go.TextBlock,
            { textAlign: "center", maxSize: new go.Size(80, NaN) },
            new go.Binding("text", "n")),
             $("Button",  // a replacement for "TreeExpanderButton" that works for non-tree-structured graphs
            // assume initially not visible because there are no links coming out
            { visible: false },
            // bind the button visibility to whether it's not a leaf node
            new go.Binding("visible", "isTreeLeaf",
              function(leaf) { return !leaf; })
              .ofObject(),
            $(go.Shape,
              {
                name: "ButtonIcon",
                figure: "MinusLine",
                desiredSize: new go.Size(6, 6)
              },
              new go.Binding("figure", "isCollapsed",  // data.isCollapsed remembers "collapsed" or "expanded"
                function(collapsed) { return collapsed ? "PlusLine" : "MinusLine"; })),
            {
              click: function(e, obj) {
                e.diagram.startTransaction();
                var node = obj.part;
                if (node.data.isCollapsed) {
                  expandFrom(node, node);
                } else {
                  collapseFrom(node, node);
                }
                e.diagram.commitTransaction("toggled visibility of dependencies");
              }
            }),
              $(go.Picture, { source: "/assets/add.png", background: "white", row: 2, column: 1, width: 20, height: 20,alignment: go.Spot.Right}),            
        ));

      function collapseFrom(node, start) {
        
        if (node.data.isCollapsed) return;
        node.diagram.model.setDataProperty(node.data, "isCollapsed", true);
        if (node != start) node.diagram.model.setDataProperty(node.data, "visible", false);
        node.findNodesOutOf().each(collapseFrom);
      }

      function expandFrom(node, start) {
        if (!node.data.isCollapsed) return;
        node.diagram.model.setDataProperty(node.data, "isCollapsed", false);
        if (node != start) node.diagram.model.setDataProperty(node.data, "visible", true);
        node.findNodesOutOf().each(expandFrom);
      }


        myDiagram.nodeTemplateMap.add("F",  // Female
        $(go.Node, "Auto",
            $(go.Shape, "Rectangle",
              { name: "OBJSHAPE", stroke: 'white', strokeWidth: 3.5,
              // set the port properties:
              portId: "", fromLinkable: false, toLinkable: false, cursor: "pointer" },
                new go.Binding("fill", "fillcolor")),
                new go.Binding("visible"),
               
          $(go.Panel, "Horizontal",
            $(go.Picture,
              {
                name: "Picture",
                desiredSize: new go.Size(70, 70),
                margin: 1.5,
              },
              new go.Binding("source", "img")),
            { click: function(e, obj) { viewProfile();zoomSlider.remove(); } },
            // define the panel where the text will appear
            $(go.Panel, "Table",
              {
                minSize: new go.Size(130, NaN),
                maxSize: new go.Size(150, NaN),
                margin: new go.Margin(6, 10, 0, 6),
                defaultAlignment: go.Spot.Left
              },
              $(go.RowColumnDefinition, { column: 2, width: 4 }),
              $("HyperlinkText",
              function(node) { return "#"; },
              function(node) { return "Invite To Pidhi"; },
              {row: 0, column: 0, columnSpan: 5,stroke: "white",font: "8pt sans-serif", margin:5, minSize: new go.Size(10, 16)}),
              $(go.TextBlock, "", textStyle(),
                { row: 1, column: 0 }),
              $(go.TextBlock, textStyle(),
                {
                  row: 1, column: 1, columnSpan: 4,
                  editable: true, isMultiline: false,
                  minSize: new go.Size(10, 14),
                  margin: new go.Margin(0, 0, 0, 3)
                },
                new go.Binding("text", "fname").makeTwoWay()),
                //new go.Binding("text", "lname").makeTwoWay()),
            )  // end Table Panel
          ), // end Horizontal Panel
          $(go.TextBlock,
            { textAlign: "center", maxSize: new go.Size(80, NaN) },
            new go.Binding("text", "n")),
             $("Button",  // a replacement for "TreeExpanderButton" that works for non-tree-structured graphs
            // assume initially not visible because there are no links coming out
            { visible: false },
            // bind the button visibility to whether it's not a leaf node
            new go.Binding("visible", "isTreeLeaf",
              function(leaf) { return leaf; })
              .ofObject(),
            $(go.Shape,
              {
                name: "ButtonIcon",
                figure: "MinusLine",
                desiredSize: new go.Size(6, 6)
              },
              new go.Binding("figure", "isCollapsed",  // data.isCollapsed remembers "collapsed" or "expanded"
                function(collapsed) { return collapsed ? "PlusLine" : "MinusLine"; })),
            {
              click: function(e, obj) {
                e.diagram.startTransaction();
                var node = obj.part;
                if (node.data.isCollapsed) {
                  expandFrom(node, node);
                } else {
                  collapseFrom(node, node);
                }
                e.diagram.commitTransaction("toggled visibility of dependencies");
              }
            }),
           //contextMenu icon
              $(go.Picture, { source: "/assets/add.png", background: "white", row: 2, column: 1, width: 20, height: 20,alignment: go.Spot.Right}),
        ));
  
      // the representation of each label node -- nothing shows on a Marriage Link
      myDiagram.nodeTemplateMap.add("LinkLabel",
        $(go.Node, { name: "OBJSHAPE",selectable: true, width: 1, height: 1, fromEndSegmentLength: 20 }));

      function highlightLink(link, show) {
        link.isHighlighted = show;
        link.fromNode.isHighlighted = show;
        link.toNode.isHighlighted = show;
      }

  // define the link template
      myDiagram.linkTemplate =
        $(go.Link,
          {
            selectionAdornmentTemplate:
              $(go.Adornment,
                $(go.Shape,
                  { isPanelMain: true, stroke: "dodgerblue", strokeWidth: 3 }),
                $(go.Shape,
                  { toArrow: "Standard", fill: "dodgerblue", stroke: null, scale: 1 })
              ),
            routing: go.Link.Normal,
            curve: go.Link.Bezier,
            toShortLength: 2
          },
          $(go.Shape,  //  the link shape
            { name: "OBJSHAPE" }),
          $(go.Shape,  //  the arrowhead
            { name: "ARWSHAPE", toArrow: "Standard" }),
        );


      myDiagram.linkTemplateMap.add("Marriage",  // for marriage relationships
        $(go.Link,
          {
            selectionAdornmentTemplate:
              $(go.Adornment,
                $(go.Shape,
                  { isPanelMain: true, stroke: "dodgerblue", strokeWidth: 3 }),
                $(go.Shape,
                  { toArrow: "Standard", fill: "dodgerblue", stroke: null, scale: 1 })
              ),
            routing: go.Link.Normal,
            curve: go.Link.Bezier,
            toShortLength: 2
          },
          $(go.Shape,  //  the link shape
            { name: "OBJSHAPE" }),
          $(go.Shape,  //  the arrowhead
            { name: "ARWSHAPE", toArrow: "Standard" }),
        ));


      // n: name, s: sex, m: mother, f: father, ux: wife, vir: husband, a: attributes/markers
      setupDiagram(myDiagram,jsonData);

            // whenever selection changes, run updateHighlights
      myDiagram.addDiagramListener("ChangedSelection",
        function() { updateHighlights(); });

      myDiagram.select(myDiagram.findNodeForKey('C'));

    }

    function updateHighlights() {
      // Set highlight to 0 for everything before updating
      myDiagram.nodes.each(function(node) { node.highlight = 0; });
      myDiagram.links.each(function(link) { link.highlight = 0; });
      var sel = myDiagram.selection.first();
      nodesReach(sel, 1)
      // Give everything the appropriate highlighting ( color and width of stroke )
      // nodes, including groups
      myDiagram.nodes.each(function(node) {
        var shp = node.findObject("OBJSHAPE");
        var grp = node.findObject("GROUPTEXT");
        var hl = node.highlight;
        console.log(node.highlight);
         console.log("called linkTo");
        highlight(shp, grp, hl);
      });
      // links
      myDiagram.links.each(function(link) {
        console.log(link)
        var hl = link.highlight;
        var shp = link.findObject("OBJSHAPE");
        var arw = link.findObject("ARWSHAPE");
        highlight(shp, arw, hl);
      });

    }
    // same as childNodes, then run allMemberNodes for each child Group with the next color
    // if the link connects to this node, highlight it
       function nodesReach(x, i) {
      if (x instanceof go.Link) {
        x.toNode.highlight = i;
        nodesReach(x.toNode, i + 1);
      } else {
        x.findNodesOutOf().each(function(node) {
          if (node.highlight === 0 || node.highlight > i) {
            node.highlight = i;
            nodesReach(node, i + 1);
          }
        });
      }
      if (x instanceof go.Node) {
        x.linksConnected.each(function(link) { link.highlight = i; });
      }
    }

   function highlight(shp, obj2, hl) {
      var color;
      var width = 3;
      if (hl === 0) { color = "green"; width = 2; }
      else if (hl === 1) { color = "blue"; }
      else if (hl === 2) { color = "green"; }
      else if (hl === 3) { color = "orange"; }
      else if (hl === 4) { color = "red"; }
      else { color = "purple"; }
      shp.stroke = color;
      shp.strokeWidth = width;
      console.log(color);
      if (obj2 !== null) {
        obj2.stroke = color;
        obj2.fill = color;
      }
    }
    // create and initialize the Diagram.model given an array of node data representing people
    function setupDiagram(diagram, array, focusId) {
      diagram.model =
        go.GraphObject.make(go.GraphLinksModel,
          { // declare support for link label nodes
            linkLabelKeysProperty: "labelKeys",
            // this property determines which template is used
            nodeCategoryProperty: "s",
            // if a node data object is copied, copy its data.a Array
            copiesArrays: true,
            // create all of the nodes for people
            nodeDataArray: array
          });
      setupMarriages(diagram);
      setupParents(diagram);

      var node = diagram.findNodeForKey(focusId);
      if (node !== null) {
        diagram.select(node);
        // remove any spouse for the person under focus:
        node.linksConnected.each(function(l) {
          if (!l.isLabeledLink) return;
          l.opacity = 0;
          var spouse = l.getOtherNode(node);
          spouse.opacity = 0;
          spouse.pickable = false;
        });
      }
    }

    function findMarriage(diagram, a, b) {  // A and B are node keys
      var nodeA = diagram.findNodeForKey(a);
      var nodeB = diagram.findNodeForKey(b);
      if (nodeA !== null && nodeB !== null) {
        var it = nodeA.findLinksBetween(nodeB);  // in either direction
        while (it.next()) {
          var link = it.value;
          // Link.data.category === "Marriage" means it's a marriage relationship
          if (link.data !== null && link.data.category === "Marriage") return link;
        }
      }
      return null;
    }

    // now process the node data to determine marriages
    function setupMarriages(diagram) {
      var model = diagram.model;
      var nodeDataArray = model.nodeDataArray;
      for (var i = 0; i < nodeDataArray.length; i++) {
        var data = nodeDataArray[i];
        var key = data.key;
        var uxs = data.ux;
        if (uxs !== undefined) {
          if (typeof uxs === "number") uxs = [uxs];
          for (var j = 0; j < uxs.length; j++) {
            var wife = uxs[j];
            if (key === wife) {
              // or warn no reflexive marriages
              continue;
            }
            var link = findMarriage(diagram, key, wife);
            if (link === null) {
              // add a label node for the marriage link
              var mlab = { s: "LinkLabel" };
              model.addNodeData(mlab);
              // add the marriage link itself, also referring to the label node
              var mdata = { from: key, to: wife, labelKeys: [mlab.key], category: "Marriage" };
              model.addLinkData(mdata);
            }
          }
        }
        var virs = data.vir;
        if (virs !== undefined) {
          if (typeof virs === "number") virs = [virs];
          for (var j = 0; j < virs.length; j++) {
            var husband = virs[j];
            if (key === husband) {
              // or warn no reflexive marriages
              continue;
            }
            var link = findMarriage(diagram, key, husband);
            if (link === null) {
              // add a label node for the marriage link
              var mlab = { s: "LinkLabel" };
              model.addNodeData(mlab);
              // add the marriage link itself, also referring to the label node
              var mdata = { from: key, to: husband, labelKeys: [mlab.key], category: "Marriage" };
              model.addLinkData(mdata);
            }
          }
        }
      }
    }

    // process parent-child relationships once all marriages are known
    function setupParents(diagram) {
      var model = diagram.model;
      var nodeDataArray = model.nodeDataArray;
      for (var i = 0; i < nodeDataArray.length; i++) {
        var data = nodeDataArray[i];
        var key = data.key;
        var mother = data.m;
        var father = data.f;
        if (mother !== undefined && father !== undefined) {
          var link = findMarriage(diagram, mother, father);
          if (link === null) {
            // or warn no known mother or no known father or no known marriage between them
            if (window.console) window.console.log("unknown marriage: " + mother + " & " + father);
            continue;
          }
          var mdata = link.data;
          var mlabkey = mdata.labelKeys[0];
          var cdata = { from: mlabkey, to: key };
          
          myDiagram.model.addLinkData(cdata);
        }
      }
    }


    // A custom layout that shows the two families related to a person's parents
    function GenogramLayout() {
      go.LayeredDigraphLayout.call(this);
      this.initializeOption = go.LayeredDigraphLayout.InitDepthFirstOut;
      this.linkSpacing = 20
      this.layerSpacing = 90
      this.spouseSpacing = 30;  // minimum space between spouses
    }
    go.Diagram.inherit(GenogramLayout, go.LayeredDigraphLayout);

    GenogramLayout.prototype.makeNetwork = function(coll) {
      // generate LayoutEdges for each parent-child Link
      var net = this.createNetwork();
      if (coll instanceof go.Diagram) {
        this.add(net, coll.nodes, true);
        this.add(net, coll.links, true);
      } else if (coll instanceof go.Group) {
        this.add(net, coll.memberParts, false);
      } else if (coll.iterator) {
        this.add(net, coll.iterator, false);
      }
      return net;
    };
    GenogramLayout.getSiblingNumber = function(v) { 
       if (v && v.node) {
        siblingNode = parseInt(v.node.data.sibling);
        if (v.node.data && typeof siblingNode === "number") {
          return siblingNode;
        } else if (v.node.isLinkLabel) {
          var marrlink = v.node.labeledLink;
          if (marrlink && marrlink.fromNode && marrlink.fromNode.data && typeof marrlink.fromNode.data.sibling === "number") {
            return marrlink.fromNode.data.sibling;
          }
          if (marrlink && marrlink.toNode && marrlink.toNode.data && typeof marrlink.toNode.data.sibling === "number") {
            return marrlink.toNode.data.sibling;
          }
        }
      }
      return 999;  // at most a thousand siblings in any family
    }

    GenogramLayout.getParentIndex = function(v) {  // static function for sorting
      if (v && v.node) {
        var it = v.sourceEdges.iterator;
        while (it.next()) {
          var e = it.value;
          if (e.fromVertex && e.fromVertex.node && e.fromVertex.node.isLinkLabel) {
            return e.fromVertex.index;
          }
        }
      }
      return -1;
    }

    GenogramLayout.prototype.initializeIndices = function() {
      go.LayeredDigraphLayout.prototype.initializeIndices.call(this);

      // accumulate all vertexes for each layer, in order of their .index
      var layers = [];
      var vertIter = this.network.vertexes.iterator;
      while (vertIter.next()) {
        var vertex = vertIter.value;
        var layer = vertex.layer;
        var lay = layers[layer];
        if (!lay) { lay = []; layers[layer] = lay; }
        lay[vertex.index] = vertex;
      }

      // iterate over all layers, from the top down, ordering all vertexes in the next layer
      for (var l = layers.length-1; l >= 0; l--) {
        var lay = layers[l];
        if (lay && lay.length > 0) {
          lay.sort(function(v, w) {
            var vx = GenogramLayout.getSiblingNumber(v);
            vx += GenogramLayout.getParentIndex(v) * 1000;
            var wx = GenogramLayout.getSiblingNumber(w);
            wx += GenogramLayout.getParentIndex(w) * 1000;
            if (vx < wx) return -1;
            if (vx > wx) return 1;
            return 0;
          });
          for (var i = 0; i < lay.length; i++) {
            var v = lay[i];
            v.index = i;
          }
        }
      }
    }

    // disable re-ordering of vertexes in layers for link crossing reductions
   // GenogramLayout.prototype.reduceCrossings = function() {}


    // internal method for creating LayeredDigraphNetwork where husband/wife pairs are represented
    // by a single LayeredDigraphVertex corresponding to the label Node on the marriage Link
    GenogramLayout.prototype.add = function(net, coll, nonmemberonly) {
      var multiSpousePeople = new go.Set();
      // consider all Nodes in the given collection
      var it = coll.iterator;
      while (it.next()) {
        var node = it.value;
       
        if (!(node instanceof go.Node)) continue;
        if (!node.isLayoutPositioned || !node.isVisible()) continue;
        if (nonmemberonly && node.containingGroup !== null) continue;
        // if it's an unmarried Node, or if it's a Link Label Node, create a LayoutVertex for it
        if (node.isLinkLabel) {
          // get marriage Link
          var link = node.labeledLink;
          var spouseA = link.fromNode;
          var spouseB = link.toNode;
          // create vertex representing both husband and wife
          var vertex = net.addNode(node);
          // now define the vertex size to be big enough to hold both spouses
          vertex.width = spouseA.actualBounds.width + this.spouseSpacing + spouseB.actualBounds.width;
          vertex.height = Math.max(spouseA.actualBounds.height, spouseB.actualBounds.height);
          vertex.focus = new go.Point(spouseA.actualBounds.width + this.spouseSpacing / 2, vertex.height / 2);
        } else {
          // don't add a vertex for any married person!
          // instead, code above adds label node for marriage link
          // assume a marriage Link has a label Node
          var marriages = 0;
          node.linksConnected.each(function(l) { if (l.isLabeledLink) marriages++; });
          if (marriages === 0) {
            var vertex = net.addNode(node);
          } else if (marriages > 1) {
            multiSpousePeople.add(node);
          }
        }
      }
      // now do all Links
      it.reset();
      while (it.next()) {
        var link = it.value;
        if (!(link instanceof go.Link)) continue;
        if (!link.isLayoutPositioned || !link.isVisible()) continue;
        if (nonmemberonly && link.containingGroup !== null) continue;
        // if it's a parent-child link, add a LayoutEdge for it
        if (!link.isLabeledLink) {
          var parent = net.findVertex(link.fromNode);  // should be a label node
          var child = net.findVertex(link.toNode);
          if (child !== null) {  // an unmarried child
            net.linkVertexes(parent, child, link);
          } else {  // a married child
            link.toNode.linksConnected.each(function(l) {
              if (!l.isLabeledLink) return;  // if it has no label node, it's a parent-child link
              // found the Marriage Link, now get its label Node
              var mlab = l.labelNodes.first();
              // parent-child link should connect with the label node,
              // so the LayoutEdge should connect with the LayoutVertex representing the label node
              var mlabvert = net.findVertex(mlab);
              if (mlabvert !== null) {
                net.linkVertexes(parent, mlabvert, link);
              }
            });
          }
        }
      }

      while (multiSpousePeople.count > 0) {
        // find all collections of people that are indirectly married to each other
        var node = multiSpousePeople.first();
        var cohort = new go.Set();
        this.extendCohort(cohort, node);
        // then encourage them all to be the same generation by connecting them all with a common vertex
        var dummyvert = net.createVertex();
        net.addVertex(dummyvert);
        var marriages = new go.Set();
        cohort.each(function(n) {
          n.linksConnected.each(function(l) {
            marriages.add(l);
          })
        });
        marriages.each(function(link) {
          // find the vertex for the marriage link (i.e. for the label node)
          var mlab = link.labelNodes.first()
          var v = net.findVertex(mlab);
          if (v !== null) {
            net.linkVertexes(dummyvert, v, null);
          }
        });
        // done with these people, now see if there are any other multiple-married people
        multiSpousePeople.removeAll(cohort);
      }
    };

    // collect all of the people indirectly married with a person
    GenogramLayout.prototype.extendCohort = function(coll, node) {
      if (coll.has(node)) return;
      coll.add(node);
      var lay = this;
      node.linksConnected.each(function(l) {
        if (l.isLabeledLink) {  // if it's a marriage link, continue with both spouses
          lay.extendCohort(coll, l.fromNode);
          lay.extendCohort(coll, l.toNode);
        }
      });
    };

    GenogramLayout.prototype.assignLayers = function() {
      go.LayeredDigraphLayout.prototype.assignLayers.call(this);
      var horiz = this.direction == 0.0 || this.direction == 180.0;
      // for every vertex, record the maximum vertex width or height for the vertex's layer
      var maxsizes = [];
      this.network.vertexes.each(function(v) {
        var lay = v.layer;
        var max = maxsizes[lay];
        if (max === undefined) max = 0;
        var sz = (horiz ? v.width : v.height);
        if (sz > max) maxsizes[lay] = sz;
      });
      // now make sure every vertex has the maximum width or height according to which layer it is in,
      // and aligned on the left (if horizontal) or the top (if vertical)
      this.network.vertexes.each(function(v) {
        var lay = v.layer;
        var max = maxsizes[lay];
        if (horiz) {
          v.focus = new go.Point(0, v.height / 2);
          v.width = max;
        } else {
          v.focus = new go.Point(v.width / 2, 0);
          v.height = max;
        }
      });
      // from now on, the LayeredDigraphLayout will think that the Node is bigger than it really is
      // (other than the ones that are the widest or tallest in their respective layer).
    };


    GenogramLayout.prototype.commitNodes = function() {
      go.LayeredDigraphLayout.prototype.commitNodes.call(this);
      // position regular nodes
      this.network.vertexes.each(function(v) {
        if (v.node !== null && !v.node.isLinkLabel) {
          v.node.position = new go.Point(v.x, v.y);
        }
      });
      // position the spouses of each marriage vertex
      var layout = this;
      this.network.vertexes.each(function(v) {
        if (v.node === null) return;
        if (!v.node.isLinkLabel) return;
        var labnode = v.node;
        var lablink = labnode.labeledLink;
        // In case the spouses are not actually moved, we need to have the marriage link
        // position the label node, because LayoutVertex.commit() was called above on these vertexes.
        // Alternatively we could override LayoutVetex.commit to be a no-op for label node vertexes.
        lablink.invalidateRoute();
        var spouseA = lablink.fromNode;
        var spouseB = lablink.toNode;
        // prefer fathers on the left, mothers on the right
        if (spouseA.data.s === "F") {  // sex is female
          var temp = spouseA;
          spouseA = spouseB;
          spouseB = temp;
        }
        // see if the parents are on the desired sides, to avoid a link crossing
        var aParentsNode = layout.findParentsMarriageLabelNode(spouseA);
        var bParentsNode = layout.findParentsMarriageLabelNode(spouseB);
        if (aParentsNode !== null && bParentsNode !== null && aParentsNode.position.x > bParentsNode.position.x) {
          // swap the spouses
          var temp = spouseA;
          spouseA = spouseB;
          spouseB = temp;
        }
        spouseA.position = new go.Point(v.x, v.y);
        spouseB.position = new go.Point(v.x + spouseA.actualBounds.width + layout.spouseSpacing, v.y);
        if (spouseA.opacity === 0) {
          var pos = new go.Point(v.centerX - spouseA.actualBounds.width / 2, v.y);
          spouseA.position = pos;
          spouseB.position = pos;
        } else if (spouseB.opacity === 0) {
          var pos = new go.Point(v.centerX - spouseB.actualBounds.width / 2, v.y);
          spouseA.position = pos;
          spouseB.position = pos;
        }
      });
      // position only-child nodes to be under the marriage label node
      this.network.vertexes.each(function(v) {
        if (v.node === null || v.node.linksConnected.count > 1) return;
        var mnode = layout.findParentsMarriageLabelNode(v.node);
        if (mnode !== null && mnode.linksConnected.count === 1) {  // if only one child
          var mvert = layout.network.findVertex(mnode);
          var newbnds = v.node.actualBounds.copy();
          newbnds.x = mvert.centerX - v.node.actualBounds.width / 2;
          // see if there's any empty space at the horizontal mid-point in that layer
          var overlaps = layout.diagram.findObjectsIn(newbnds, function(x) { return x.part; }, function(p) { return p !== v.node; }, true);
          if (overlaps.count === 0) {
            v.node.move(newbnds.position);
          }
        }
      });
    };

    GenogramLayout.prototype.findParentsMarriageLabelNode = function(node) {
      var it = node.findNodesInto();
      while (it.next()) {
        var n = it.value;
        if (n.isLinkLabel) return n;
      }
      return null;
    };
    function cxcommand(event, val) {

      if (val === undefined) val = event.currentTarget.id;
      var dataObj = getData()
      switch (val) {
        case "Father": popup(dataObj,"father","M") ; break;
        case "Mother": popup(dataObj,"mother","F"); break;
        case "Brother": popup(dataObj,"brother","M"); break;
        case "Sister": popup(dataObj,"sister","F"); break;
        case "Son": popup(dataObj,"son","M"); break;
        case "Daughter": popup(dataObj,"daughter","F"); break;
        case "Spouse": popupspouse(dataObj,"spouse"); break;
      }
      diagram.currentTool.stopTool();
    }
    function popup(dataObj,relation,gender){
      $(".modal-body #id").val(dataObj.key);
       $(".modal-body #relationtype").val(relation);
       $(".modal-body #familyid").val(dataObj.familyid);
       $(".modal-body #gender").val(gender);
       $(".modal-body #rootgender").val(dataObj.s);
       $(".modal-body #f").val(dataObj.f);
       $(".modal-body #m").val(dataObj.m);
       $(".modal-body #ux").val(dataObj.ux);
       $(".modal-body #vir").val(dataObj.vir);
      $('#response').modal('show')
    }
    function popupspouse(dataObj,relation){
      $(".modal-body #id").val(dataObj.key);
       $(".modal-body #relationtype").val(relation);
       $(".modal-body #familyid").val(dataObj.familyid);
       $(".modal-body #gender").val(dataObj.s);
       $(".modal-body #f").val(dataObj.f);
       $(".modal-body #m").val(dataObj.m);
       $(".modal-body #ux").val(dataObj.ux);
       $(".modal-body #vir").val(dataObj.vir);
      $('#response').modal('show')
    }
    function Invite(){
      $('#invite').modal('show')
    }
    function viewProfile(){

      var profile = getData()
      $('#leftModal #myModalLabel').html(profile.fname)
      if(profile.img){
         $('#leftModal #uimage').attr("src",profile.img);
      }
      else{
        $('#leftModal #uimage').attr("src",'assets/missing.png');
      }
      $('#fname').html(profile.fname);
      $('#lname').html(profile.lname);
      $('#dob').html(profile.dob);
      $('#email').html(profile.email);
      $('#mobile').html(profile.mobile);
      $('#skey').val(profile.key);
      $('#semail').val(profile.email);
      $("#isalive").val(profile.isalive);
      $("#sibling").html(profile.sibling);
      editablefunction(profile);
      $('#leftModal').modal('show');
    }
     function editablefunction(profile){
      $('#fname').editable({
        type: 'text',
        pk: profile.key,
        url: '/genogram_edit',
        title: 'Enter username',
        success: function(response, newValue) {
        editableSuccess(response);
        if(response.status == 'error') return response.msg; //msg will be shown in editable form
    }
    });
           $('#lname').editable({
        type: 'text',
        pk: profile.key,
        url: '/genogram_edit',
        title: 'Enter Lastname',
        success: function(response, newValue) {
        editableSuccess(response);
        if(response.status == 'error') return response.msg; //msg will be shown in editable form
    }
    });
    $('#oname').editable({
        type: 'text',
        pk: profile.key,
        url: '/genogram_edit',
        title: 'Enter Nickname',
        success: function(response, newValue) {
        editableSuccess(response);
        if(response.status == 'error') return response.msg; //msg will be shown in editable form
    }
    });
    $('#dob').editable({
        type: "date",
        pk: profile.key,
        format: 'yyyy-mm-dd', 
        url: '/genogram_edit',   
        viewformat: 'yyy-mm-dd',    
        datepicker: {
                weekStart: 1
           },
        success: function(response, newValue) {
        editableSuccess(response);
        if(response.status == 'error') return response.msg; //msg will be shown in editable form
    }
      });
    $('#email').editable({
        type: 'text',
        pk: profile.key,
        url: '/genogram_edit',
        title: 'Enter Email',
        success: function(response, newValue) {
        editableSuccess(response);
        if(response.status == 'error') return response.msg; //msg will be shown in editable form
    }
    });
    $('#mobile').editable({
        type: 'text',
        pk: profile.key,
        url: '/genogram_edit',
        title: 'Enter Mobile',
        success: function(response, newValue) {
        editableSuccess(response);
        if(response.status == 'error') return response.msg; //msg will be shown in editable form
    }
    });
    $('#isalive').editable({
        type: 'select',
        pk: profile.key,
        url: '/genogram_edit',
        value: true,    
        source: [
              {value: true, text: 'Yes'},
              {value: false, text: 'No'}
           ],
        success: function(response, newValue) {
        editableSuccess(response);
        if(response.status == 'error') return response.msg; //msg will be shown in editable form
    }
    });
    $('#sibling').editable({
        type: 'select',
        pk: profile.key,
        url: '/genogram_edit',
        value: "",    
        source: [
              {value: 1, text: '1'},
              {value: 2, text: '2'},
              {value: 3, text: '3'},
              {value: 4, text: '4'},
              {value: 5, text: '5'},
              {value: 6, text: '6'},
              {value: 6, text: '7'},
              {value: 6, text: '8'}
           ],
    success: function(response, newValue) {
        editableSuccess(response);
        if(response.status == 'error') return response.msg; //msg will be shown in editable form
    }
    });
    $('#fname').editable('setValue', profile.fname)  //clear values
        .editable('option', 'pk', profile.key)          //clear pk
        .removeClass('editable-unsaved');  
    $('#lname').editable('setValue', profile.lname)  //clear values
        .editable('option', 'pk', profile.key)          //clear pk
        .removeClass('editable-unsaved'); 
    $('#oname').editable('setValue', profile.oname)  //clear values
        .editable('option', 'pk', profile.key)          //clear pk
        .removeClass('editable-unsaved'); 

    $('#dob').editable('setValue', Date.parse("yyyy-mm-dd",profile.dob))  //clear values
        .editable('option', 'pk', profile.key)          //clear pk
        .removeClass('editable-unsaved'); 
    $('#email').editable('setValue', profile.email)  //clear values
        .editable('option', 'pk', profile.key)          //clear pk
        .removeClass('editable-unsaved'); 
    $('#mobile').editable('setValue', profile.mobile)  //clear values
        .editable('option', 'pk', profile.key)          //clear pk
        .removeClass('editable-unsaved'); 
    $('#isalive').editable('setValue', profile.isalive)  //clear values
        .editable('option', 'pk', profile.key)          //clear pk
        .removeClass('editable-unsaved'); 
    $('#sibling').editable('setValue', profile.sibling)  //clear values
        .editable('option', 'pk', profile.key)          //clear pk
        .removeClass('editable-unsaved'); 
    }

    function getData(){
      var diagram = myDiagram;
      var model = diagram.model;
      var dataObj = "";
      var nodeDataArray = model.nodeDataArray;
      diagram.selection.each(function(node) {
        dataObj = node.data
      })
      return dataObj;
    }

 function editableSuccess(response){
        if(response != 0){
          $('#uimage').attr('src', response["response"]);
           $.ajax({
                  type: 'GET',
                  contentType: 'application/json; charset=utf-8',
                  url: '/getGenogramData',
                  dataType: 'json',
                  success: function(data){
                  jsonData = data.doc;
                  myDiagram.div = null;
                 }
           })
        }else{
          return response.msg;
        }
 }
  </script>
<body>
	<div id="sample" style="position: relative;">
  <div id="myDiagramDiv" style="background-color: #34343C; border: solid 1px black; height: 570px;"></div></div>
<script type="text/javascript">
  $.fn.editable.defaults.mode = 'popup';
  $(document).ready(function(){
  $('#btn_upload').click(function(){
    var fd = new FormData();
    var email = $('#semail').val();
    var key = $('#skey').val();
    var files = $('#file')[0].files[0];
    fd.append('file',files);
    fd.append('email',email);
    fd.append('key',key);
    // AJAX request
    $.ajax({
      url: '/genogram_upload',
      type: 'post',
      data: fd,
      contentType: false,
      processData: false,
      success: function(response){
        if(response != 0){
          //console.log(response[response]);
          $('#uimage').attr('src', response["response"]);
           $.ajax({
                  type: 'GET',
                  contentType: 'application/json; charset=utf-8',
                  url: '/getGenogramData',
                  dataType: 'json',
                  success: function(data){
                  jsonData = data.doc;
                  myDiagram.div = null
                  init()
                  $('#uploadModal').modal('hide')
                 }
           })
        }else{
          $('#error').append("Error on File upload");
        }
      }
    });
  });
  //Image preview
      function readURL(input) {
      if (input.files && input.files[0]) {
      var reader = new FileReader();

      reader.onload = function(e) {
      $('#preview').attr('src', e.target.result);
      }
      reader.readAsDataURL(input.files[0]); // convert to base64 string
      }
      }

      $("#file").change(function() {
      readURL(this);
      });
      $('#uploadModal').on('hidden.bs.modal', function (e) {
      $(this)
        .find("#file")
         .val('')
         .end()
      .find("input[type=checkbox], input[type=radio]")
         .prop("checked", "")
         .end()
      .find("#preview")
         .prop("src", "")
         .end();
})
    $('#leftModal').on('hidden.bs.modal', function (e) {
      $(this)
        .find("input")
         .val('')
         .end()
        .find("hidden")
         .val('')
         .end()
      .find("input[type=checkbox], input[type=radio]")
         .prop("checked", "")
         .end();
          myDiagram.div = null
        init()
})
  $('#delete').click(function(){
    var value = $('#skey').val();
    var key = 'key';
    //console.log(key);
    $.ajax({
      url: '/genogram_delete',
      type: 'post',
      data: {key:value},
      success: function(response){
        if(response != 0){
          console.log(response);
        }else{
          $('#error').append("Error on delete");
        }
      }
    });
  }); 
});

</script>
<script type="javascript" src="/javascripts/Buttons.js"></script>